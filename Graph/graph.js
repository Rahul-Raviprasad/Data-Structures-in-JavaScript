function Graph(v) {  this.vertices = v;  this.edges = 0;  this.adj = [];  for (var i = 0; i < this.vertices; ++i) {    this.adj[i] = [];    this.adj[i].push("");  }  this.addEdge = addEdge;  this.showGraph = showGraph;  this.dfs = dfs;  this.marked = [];  for (var i = 0; i < this.vertices; ++i) {    this.marked[i] = false;  }}function addEdge(v,w) {  this.adj[v].push(w);  this.adj[w].push(v);  this.edges++;}function showGraph() {  for (var i = 0; i < this.vertices; ++i) {    putstr(i + " -> ");    for (var j = 0; j < this.vertices; ++j) {      if (this.adj[i][j] != undefined) putstr(this.adj[i][j] + ' ');    }    print();  }}/*The algorithm for performing a depth-first search is relatively simple—visit avertex that has not already been visited, mark it as having been visited, thenrecursively visit the other unvisited vertices that are in the originalvertex’s adjacency list.*/function dfs(v) {  this.marked[v] = true;  if (this.adj[v] != undefined) {    print("Visited vertex: " + v);  }  for each (var w in this.adj[v]) {    if (!this.marked[w]) {      this.dfs(w);    }  }}/*The algorithm for breadth-first search uses a queue abstraction instead of anarray abstraction for storing visited vertices. The algorithm works as follows:1. Find an unvisited vertex that is adjacent to the current vertex,add it to the list of visited vertices, and add it to the queue.2. Take the next vertex, v, from the graph and add it to the list of visited vertices.3. Add all unmarked vertices that are are adjacent to v and add them to the queue.*/function bfs(s) {  var queue = [];  this.marked[s] = true;  queue.push(s); // add to back of queue  while (queue.length > 0) {    var v = queue.shift(); // remove from front of queue    if (v == undefined) {      print("Visited vertex: " + v);    }    for each (var w in this.adj[v]) {      if (!this.marked[w]) {        this.edgeTo[w] = v;        this.marked[w] = true;        queue.push(w);      }    }  }}