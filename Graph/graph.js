function Graph(v) {  this.vertices = v;  this.edges = 0;  this.adj = [];  for (var i = 0; i < this.vertices; ++i) {    this.adj[i] = [];    this.adj[i].push("");  }  this.addEdge = addEdge;  this.showGraph = showGraph;  this.dfs = dfs;  this.marked = [];  for (var i = 0; i < this.vertices; ++i) {    this.marked[i] = false;  }}function addEdge(v,w) {  this.adj[v].push(w);  this.adj[w].push(v);  this.edges++;}function showGraph() {  for (var i = 0; i < this.vertices; ++i) {    console.log(i + " -> ");    for (var j = 0; j < this.vertices; ++j) {      if (this.adj[i][j] != undefined) console.log(this.adj[i][j] + ' ');    }  }}/*The algorithm for performing a depth-first search is relatively simple—visit avertex that has not already been visited, mark it as having been visited, thenrecursively visit the other unvisited vertices that are in the originalvertex’s adjacency list.*/function dfs(v) {  this.marked[v] = true;  if (this.adj[v] != undefined) {    console.log("Visited vertex: " + v);  }  for each (var w in this.adj[v]) {    if (!this.marked[w]) {      this.dfs(w);    }  }}/*The algorithm for breadth-first search uses a queue abstraction instead of anarray abstraction for storing visited vertices. The algorithm works as follows:1. Find an unvisited vertex that is adjacent to the current vertex,add it to the list of visited vertices, and add it to the queue.2. Take the next vertex, v, from the graph and add it to the list of visited vertices.3. Add all unmarked vertices that are are adjacent to v and add them to the queue.*/function bfs(s) {  var queue = [];  this.marked[s] = true;  queue.push(s); // add to back of queue  while (queue.length > 0) {    var v = queue.shift(); // remove from front of queue    if (v == undefined) {      console.log("Visited vertex: " + v);    }    for each (var w in this.adj[v]) {      if (!this.marked[w]) {        this.edgeTo[w] = v;        this.marked[w] = true;        queue.push(w);      }    }  }}/////miner problem find path out of the maze and print it!!!//In this problem we are assuming that a coal miner is stuck// in a mine and needs our help to come out. We are given a//map and we need to give the path that he has to follow to come out.function solve(map, miner, exit) {  var result = [];  if(miner.x === exit.x && miner.y === exit.y) return [];  //converting the map to we can edit. We want to know if we visited a point in the graph  var newMap = [];  for(var i = 0; i < map.length; i++) {    newMap[i] = [];    for(var j = 0; j < map[i].length; j++) {      newMap[i][j] = {};      newMap[i][j].value = map[i][j];      newMap[i][j].visited = false;      newMap[i][j].x = i;      newMap[i][j].y = j;    }  } // newMap is the our map  var pathStack = new Stack();  var currPosition = newMap[miner.x][miner.y];  currPosition.visited = true;  pathStack.push(currPosition);  while(pathStack.top != 0) {    var next = findUnvisitedAdjVertex(currPosition);    if(next == null) {       var temp = pathStack.peek();       //backtrack here       if(currPosition.x == temp.x && currPosition.y == temp.y) {          pathStack.pop();       }       currPosition = pathStack.pop();       result.pop(); // updating result stack to forget the move made    } else {        if(next.x == exit.x && next.y == exit.y) {          console.log("exit found");          return result;        }        pathStack.push(next);        currPosition = next; //updating the current position to next pos        currPosition.visited = true;    }  }  function findUnvisitedAdjVertex(pos) {    if (pos) {      if(pos.x >= 1 && newMap[pos.x - 1] && newMap[pos.x - 1][pos.y] && newMap[pos.x - 1][pos.y].value == true  && newMap[pos.x - 1][pos.y].visited == false ) {        //left position is free and is unvisited        result.push("left");        return newMap[pos.x-1][pos.y];      } else if (pos.y >= 1 && newMap[pos.x] && newMap[pos.x][pos.y-1] && newMap[pos.x][pos.y-1].value == true  && newMap[pos.x][pos.y-1].visited == false ) {        //top hasn't been visited and is free        result.push("up");        return newMap[pos.x][pos.y-1];      } else if(pos.x+1 < newMap.length && newMap[pos.x + 1] && newMap[pos.x + 1][pos.y] && newMap[pos.x + 1][pos.y].value == true  && newMap[pos.x + 1][pos.y].visited == false ) {        //left position is free and is unvisited        result.push("right");        return newMap[pos.x+1][pos.y];      } else if (pos.y+1 < newMap[0].length && newMap[pos.x] && newMap[pos.x][pos.y+1] && newMap[pos.x][pos.y+1].value == true  && newMap[pos.x][pos.y+1].visited == false ) {        //bottom hasn't been visited and is free        result.push("down");        return newMap[pos.x][pos.y+1];      }    }    return null;  }  return result;}//Using stack to maintain the last visited place and later backtrackfunction Stack() {  this.dataStore = [];  this.top = 0; // points to the empty space in the Stack yet to be filled  this.push = push;  this.pop = pop;  this.peek = peek;  function push(element) {    this.dataStore[this.top++] = element; //set the element at top and THEN increment top  }  function pop() {    return this.dataStore[--this.top];  }  function peek() {    return this.dataStore[this.top - 1];  }  function length() {    return this.top;  }  function clear() {    this.top = 0;  }}